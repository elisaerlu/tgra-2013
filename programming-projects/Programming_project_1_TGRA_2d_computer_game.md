#Computer Graphics Programming assignment 1: 2D computer game
This document describes the first programming assignment in the course
T-511-TGRA. The goal in this assignment is to write a fully functional, and
playable, 2D computer game.

#Project goal
In this project students can use LibGDX to make an OpenGL ES, or vanilla
OpenGL/Glut to implement their 2D game. Many students have been sending me email regarding programming languages. If you want to use some other exotic programming language - We don't care. Just be sure that you hand in your game with instructions how to build that game and list of requirements that we must install before running the game. If you pick paradigms that we are not used we might ask you to explain your code. 

The game must, at the very least,
include two objects, at least one of them moving by some rule and the
possibility of affecting some objects movement by input from the keyboard,
mouse, touchscreen or accelerometer. 

In most cases there will be more than one moving objects, some moving
automatically and some by input. In some cases the same objects will move by
some automatic rule and also be affected by input.

The game should include some form of collision detection between these objects
and other (static or mobile) objects that may be in the game. The game will
have some goal for the player and when that goal is fulfilled the program
should acknowledge the "victory" and start over (optionally at a more difficult
setting or in a new level). Certain situations shall also make the player
“lose” the game – the program will then acknowledge that fact and then start
completely over.Objects in the game shall at the very least be in two
different colors. If these minimum requirements are fulfilled the game would
include two moving objects, each in it's own color. The following examples are
in now way the only options and students could possibly make some kind mix of
the two or take elements from a game that's not being implemented, just to
spice up their own game. It's a good idea to read the implementation ideas for
all these games even though a student may have made up their mind already.

#Android example 1 (also eligible for desktop): Gravity sling shotThe player shoots a ball with a sling shot, controlling it‘s force and directionally dragging a finger (or mouse) from the initial position of the ball, stretching the sling. The goal is to hit a target. Round objects (planets) block the path to the target but also affect the ball through gravitational pull. The gravity can be used to control the ball in but hitting the planets will result in a loss result.Here the ball must have a speed vector (both for speed and direction). The initial speed results from the player‘s pull. The speed must change every frame depending on distance from the planets and their gravity (linear correlation between size and gravity is probably the most intuitive for playing). Simply find the vector between the ball‘s and each planet‘s centers and use that as a base for the speed change. That same vector‘s length can also be used to check if the ball has collided with the planet. If the target is hit, load or create a new level. If a planet is hit, try the same level again (or game over if all lives are lost and the game is designed that way).Desktop example 1 (also eligible for Android): Break-outIn this game's simplest form there are three types of objects, a racket sitting close to the bottom of the screen, moving by keyboard (or mouse, touch or even accelerometer) input from left to right, bricks placed in the top half of the screen and a ball that travels automatically around the screen, bouncing off the top, left and right edges of the screen, off the bricks and off the racket. When the ball bounces off a brick that brick disappears and when all bricks have disappeared the game (or that level) has been won. If the ball goes off the bottom of the screen the game (or one life) has been lost. The player has some control over the ball, as it changes it's course angle depending on where it hits the racket (center or close to edges).Implementation notes:Keep track of the ball's speed with two variables dx and dy or a 2D speed vector. When the ball bounces off walls or bricks you just switch either x or y coordinate to negative/positive.
Have the ball's direction change differently when it bounces off the racket, depending on where it hit the racket, in a way that the player can control the ball. Try to keep the ball's speed constant even though it's traveling slope changes.#Desktop example 2: AsteroidsThe player controls a space shuttle and can fly it in all directions around the screen. He controls it by rotating it around itself and hitting the “thrust” button, thus adding speed in the direction it's pointed at the time. When the shuttle has gained speed in some direction in will keep thatspeed, adding all “thrust” to the speed vector. If the shuttle leaves the edge of the game area it will re-appear at the other side of the screen at the same speed it was traveling.In the game there is a number of meteors, traveling at even speeds (set when they're created). They re-enter the game in the same way as the shuttle if they travel off the side. If the player hits the “fire” button a shot will emerge from the shuttle, at a certain speed depending on where the shuttle is pointed, with the shuttles traveling speed added. The shot has a certain lifetime before it disappears. If it hit's a meteor before it's gone it will disappear immediately and the meteor will disappear or split into two or more smaller meteors.The players goal is to clear all meteors from the screen. If the shuttle hits a meteor it's destroyed. Implementation notes:In this game you'll need two vectors for the shuttle. One for where it's pointed (or an angle for that) and one for it's traveling speed. Both the length and direction of the speed vector can change but special care should be taken not to accelerate differently if the shuttle points straight up, down or diagonally (normalize the direction/acceleration vector). The shots should also have the same speed compared to the shuttle's speed, that is, the shot speed is calculated from a normalized direction vector, but then the shuttle traveling speed is added afterwards.#Android Challenge: Labyrinth (tilting game)The screen shows a maze structure in 2D and a ball at some location within the maze. The ball can roll around freely but cannot roll through walls in the maze structure. There will be „holes“ in various places in the maze structure as well as a single target. Input will be taken from the accelerometer of the Android phone and this „tilt force“ added to the speed of the ball each frame. The goal is to get the ball to the target without hitting any of the holes.Other games:Students are welcome to implement other games but should contact the teacher to make sure that implementation is viable for this assignment.I'll be glad to help find an implementation that fits.Program design pointsSplit each frame into an „update“ part and a „display“ part. Don‘t do any graphics in the update part and don‘t change the values of any variables in the graphics part.The program must use proper time management to update speeds and positions. Use: `Gdx.graphics.getDeltaTime()`To get the time span of the last frame rendered and use that value to multiply all your speed and acceleration values as you add them to the positions and speeds respectively.The game should not be any different between fast and slow computers or phones. If a computer takes long to render a frame, objects should simply move further at a time. Scaling speeds with the time delta does exactly this for you.Use the methods in `Gdx.input` to receive your input parameters. Do this in the update part.All of these design elements are described in more detail in Lab assignments. Make sure you have read and understood those before implementing the Programming assignments.Happy gaming!
# Make your own game!
If there is any childhood game that you miss and want to recreate we encourage you to implement that game. Be sure that your game fits the above mentioned requirements and please hand in description of the game logic. If you are not sure that your game fits the requirements you can send us email or describe your game logic in class.# EvaluationThe assignment can be done in groups of two students or by single students. Grading will not be different either way. The hand-in date is on 24. September at midnight. If you need help with your game or extend time please contact the TA of this course.
