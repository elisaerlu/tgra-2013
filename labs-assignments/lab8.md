# Lab assignment 8
This document contains the eight lab assignment in the course T-511-TGRA.
## Texture mapping in OpenGl

Start this exercise with the „Sphere, lights and Game mode example“ project found under *Other material*. Make it display a single cube and a single sphere, close to each other but not at the same spot. Also make the lights and materials white (1.0, 1.0, 1.0, 1.0) to start with. You can also find the textures needed for this assignment under *Other material* named Dice and earth texture. Unpack them into an asset folder within your project.

Texture mapping is simply the act of assigning 2D coordinates within a texture image to the 3D vertices of the polygons in our scene. The texture image can be a regular digital image file - .bmp, .jpg, etc.We consider our texture to have coordinates ranging from 0.0 to 1.0 in each of it‘s two dimensions, usually called (s,t) rather than (x,y). If we were to texture a single square face on a cube we would therefor assign the (s,t) coordinates (0,0), (0,1), (1,0) and (1,1) to the face‘s vertices. If however we were to texture the face only with the top-left quarter of that texture we would instead assign the (s,t) coordinates (0, 0), (0, 0.5), (0.5, 0) and (0.5, 0.5) to it‘s vertices. Top-right corner would then be (0, 0), (0, 0.5), (1.0, 0) and (1.0, 0.5) and so on. Split the texture into 9 parts by using coordinate ranges from 0.0 to 0.33, 0.33 to 0.66 and 0.66 to 1.0.
To do this in OpenGL we need to enable:	Gdx.gl11.glEnable(GL11.GL_TEXTURE_2D);
	Gdx.gl11.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);This can be enabled in the create function but if only some of your objects are textured you should enable this in the beginning of their draw() functions and disable it again in the end of those functions.
Then we need to load texture coordinates. We do this in the same way as we load vertex coordinates and normal coordinates suing a float buffer. For textures we should just use 2 coordinates per vertex so the size of our float buffer only needs to be 2/3 of the size of our 3D vertex buffer. Each 2 floating point numbers in the textureBuffer will represent the texture coordinates for each vertex in the vertexBuffer. When you‘ve loaded your FloatBuffer for the texture coordinates point OpenGL to it using: `Gdx.gl11.glTexCoordPointer(2, GL11.GL_FLOAT, 0, texCoordBuffer);`Do this in the constructors or loading functions of the objects that use textures.
Last but not least we need to load a texture image into OpenGL. First take the texture images found under „Other material“ and copy them to a new folder in your project. In android this folder must be under the „assets“ folder and so it‘s a good idea to make that same folder structure in the desktop projects. Make a new folder called assets and inside that a folder called textures. We‘ll allow ourselves to use libGDX‘s file handling and texture loading and do this:Globally:Texture tex;Then in the loading function for your object:`tex = new Texture(Gdx.files.internal("assets/textures/first_texture.jpg"));`Internal means it's a file stored within the project. You can also use *external* for files under the user root on the desktop or the SD card root on Android. Also *absolute* for absolute paths.
You can load many different textures but OpenGL needs to know which one to use at any time. To do this there‘s „`glBind(GL_TEXTURE_2D, texID)`“ but we allow libGDX‘s Texture class to do this for us and use:`Tex.Bind();`This needs to be done in the draw() function for our object before we call `glDrawArrays()`. This simply sets a state variable pointing to the correct texture and this texture will be used until another bind call is made.
This is all ... really! The tricky part is to correctly map the texture coordinates.Lets start by texturing a simgle side of our cube. We‘ll make a simple texture buffer with only 4 (s,t) coordinates.Add `FloatBuffer texCoordBuffer;` to the Cube class.Also add `Texture tex;` to the Cube class.In the constructor in the Cube class add:
	texCoordBuffer = BufferUtils.newFloatBuffer(8);	texCoordBuffer.put(new float[] {0.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f});	texCoordBuffer.rewind();and:	tex = new Texture(Gdx.files.internal("assets/textures/first_texture.jpg"));
	
Now go to the draw() function for the cube class. Find the first drawing lines:
	Gdx.gl11.glNormal3f(0.0f, 0.0f, -1.0f);	Gdx.gl11.glDrawArrays(GL11.GL_TRIANGLE_STRIP, 0, 4);	
And seperate them from the rest. Above these lines add:
	Gdx.gl11.glEnable(GL11.GL_TEXTURE_2D);	Gdx.gl11.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY); 	Gdx.gl11.glTexCoordPointer(2, GL11.GL_FLOAT, 0, texCoordBuffer); tex.bind();Below the lines add:	Gdx.gl11.glDisable(GL11.GL_TEXTURE_2D);
	Gdx.gl11.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);


You have to disable using the texture array because you only loaded 4 (s,t) coordinates into the texture array and thus can only use it when drawing the first 4 vertices in the vertex array.
Run this and make sure you have a visible texture on one side of the cube.Now make your texture array big enough to store texture coordinates for all 6 sides of the cube (48 floats, 24 coordinate pairs). You can simply copy the first four pairs, six times over and then don‘t disable the texturing until at the end of the cube‘s drawing function. Now the texture image should be visible on all 6 sides.Now, instead of loading „first_texture.jpg“, load „dice_texture.png“. Look at the image. Change the texture coordinates in the texture buffer so that each side of the cube has one part of the dice texture. This buffer now contains what is called the model‘s UV-map.
## More interesting UV-mapping
Set up the same structure in the Sphere class. Load the texture „earth_texture1024x512“. Make a texCoordBuffer that UV-maps the texture so that it wraps around the sphere.Hint: you cat set up texS and texT intervals (the change in horixontal and vertical coordinates in each pass) which are basically 1.0 diveded by slices and stacks, respectively. Then add one interval to the texture coordinates as you add stacks and slices to the vertex coordinates. You‘re only adding 2 coordinates per vertex so you‘d use „x4“ instead of „x6“ and „x2 (+1, +2 and +3)“ instead of „x3 (+1, +2, +3, +4, +5)“. Take the time to try it out. The result is totally worth the effort!